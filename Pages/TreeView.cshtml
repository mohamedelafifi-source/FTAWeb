@page
@model TreeViewModel
@{
    ViewData["Title"] = "Family Tree";
}

<div class="tree-container">
    <div class="tree-header bg-light p-3 mb-3 d-flex justify-content-between align-items-center">
        <h3 class="mb-0">Family Tree: @Model.FileName</h3>
        <a href="/" class="btn btn-secondary">Select Another File</a>
    </div>
    <div class="tree-content" id="treeContent">
        <!-- Tree will be rendered here by JavaScript -->
    </div>
</div>

@section Scripts {
    <script>
        const treeData = @Html.Raw(Model.JsonContent);
        
        // Level color mapping
        const levelColors = {
            0: '#FFE5E5', // Light red
            1: '#E5F3FF', // Light blue
            2: '#E5FFE5', // Light green
            3: '#FFF5E5', // Light orange
            4: '#F0E5FF', // Light purple
            5: '#FFE5F0', // Light pink
            6: '#E5FFFF', // Light cyan
            7: '#FFFFE5'  // Light yellow
        };

        function getLevelColor(level) {
            return levelColors[level] || '#F5F5F5'; // Default gray
        }

        // Create a map for quick person lookup
        const personMap = new Map();
        treeData.forEach(person => {
            personMap.set(person.name, person);
        });

        // Group people by level
        const peopleByLevel = {};
        treeData.forEach(person => {
            if (!peopleByLevel[person.level]) {
                peopleByLevel[person.level] = [];
            }
            peopleByLevel[person.level].push(person);
        });

        // Get all levels sorted
        const levels = Object.keys(peopleByLevel).map(Number).sort((a, b) => a - b);

        // Organize people in each level so spouses are adjacent
        function organizeLevelPeople(people) {
            const processed = new Set();
            const result = [];
            
            people.forEach(person => {
                if (processed.has(person.name)) return;
                
                processed.add(person.name);
                result.push(person);
                
                // Add spouses right after the person
                if (person.spouses && person.spouses.length > 0) {
                    person.spouses.forEach(spouseName => {
                        const spouse = personMap.get(spouseName);
                        if (spouse && !processed.has(spouseName) && spouse.level === person.level) {
                            processed.add(spouseName);
                            result.push(spouse);
                        }
                    });
                }
            });
            
            return result;
        }

        // Render the tree
        function renderTree() {
            const container = document.getElementById('treeContent');
            container.innerHTML = '';

            levels.forEach(level => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-container mb-4';
                levelDiv.style.backgroundColor = getLevelColor(level);
                levelDiv.style.padding = '20px';
                levelDiv.style.borderRadius = '8px';
                levelDiv.style.border = '2px solid ' + adjustColorBrightness(getLevelColor(level), -20);

                const levelTitle = document.createElement('h4');
                levelTitle.textContent = `Level ${level}`;
                levelTitle.className = 'mb-3';
                levelTitle.style.color = '#333';
                levelDiv.appendChild(levelTitle);

                // Create horizontally scrollable container
                const peopleContainer = document.createElement('div');
                peopleContainer.className = 'level-people-container';
                
                // Organize people so spouses are adjacent
                const organizedPeople = organizeLevelPeople(peopleByLevel[level]);
                
                organizedPeople.forEach((person, index) => {
                    const personBox = createPersonBox(person);
                    peopleContainer.appendChild(personBox);
                    
                    // Check if next person is a spouse (bidirectional check) and add connection line
                    if (index < organizedPeople.length - 1) {
                        const nextPerson = organizedPeople[index + 1];
                        const isSpouse = (person.spouses && person.spouses.includes(nextPerson.name)) ||
                                        (nextPerson.spouses && nextPerson.spouses.includes(person.name));
                        if (isSpouse) {
                            const connector = createSpouseConnector();
                            peopleContainer.appendChild(connector);
                        } else {
                            // Add space between non-spouse boxes
                            const spacer = document.createElement('div');
                            spacer.style.width = '20px';
                            spacer.style.flexShrink = '0';
                            peopleContainer.appendChild(spacer);
                        }
                    }
                });

                levelDiv.appendChild(peopleContainer);
                container.appendChild(levelDiv);
            });
        }

        function createPersonBox(person) {
            const box = document.createElement('div');
            box.className = 'person-box';
            box.dataset.personName = person.name;
            box.style.cssText = `
                padding: 12px 20px;
                background-color: white;
                border: 2px solid #333;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.3s;
                position: relative;
                min-width: 150px;
                flex-shrink: 0;
                text-align: center;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            `;

            box.innerHTML = `<strong>${escapeHtml(person.name)}</strong>`;

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
            });

            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
            });

            return box;
        }

        function createSpouseConnector() {
            const connector = document.createElement('div');
            connector.className = 'spouse-connector';
            connector.style.cssText = `
                width: 40px;
                height: 2px;
                background: repeating-linear-gradient(
                    to right,
                    #FF6B6B 0px,
                    #FF6B6B 5px,
                    transparent 5px,
                    transparent 10px
                );
                margin: 0 10px;
                flex-shrink: 0;
                align-self: center;
            `;
            
            return connector;
        }

        function adjustColorBrightness(hex, percent) {
            const num = parseInt(hex.replace("#", ""), 16);
            const r = Math.min(255, Math.max(0, (num >> 16) + percent));
            const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
            const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // Initialize tree when page loads
        window.addEventListener('load', () => {
            renderTree();
        });

        window.addEventListener('resize', () => {
            renderTree();
        });
    </script>
}

<style>
    .tree-container {
        min-height: 100vh;
        padding: 20px;
        background-color: #f8f9fa;
    }

    .tree-content {
        overflow-y: auto;
        max-height: calc(100vh - 120px);
    }

    .level-container {
        position: relative;
        margin-bottom: 20px;
    }

    .level-people-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        overflow-x: auto;
        overflow-y: visible;
        padding: 10px 0;
        gap: 0;
        min-height: 80px;
    }

    .level-people-container::-webkit-scrollbar {
        height: 8px;
    }

    .level-people-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.1);
        border-radius: 4px;
    }

    .level-people-container::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
    }

    .level-people-container::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.5);
    }

    .person-box {
        user-select: none;
    }

    .spouse-connector {
        display: flex;
        align-items: center;
        justify-content: center;
    }
</style>
