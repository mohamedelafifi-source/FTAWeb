@page "{familyName}"
@model TreeViewModel
@{
    ViewData["Title"] = "Family Tree: " + Model.FileName;
}

<div class="tree-container">
    <div class="tree-header bg-light p-3 mb-3 d-flex justify-content-between align-items-center">
        <h3 class="mb-0" id="treeTitle">Family Tree: @Model.FileName</h3>
        <div>
            <button id="syncScrollBtn" class="btn btn-info me-2">
                <span id="syncScrollIcon">ðŸ”—</span> Sync Scroll: <span id="syncScrollStatus">Off</span>
            </button>
            <button id="exitFocusBtn" class="btn btn-warning me-2" style="display: none;">Exit Focus Mode</button>
            <a asp-page="/FamilyDetail" asp-route-familyName="@Model.FamilyName" class="btn btn-secondary">Back to Family</a>
        </div>
    </div>
    <div class="tree-content" id="treeContent">
        <!-- Tree will be rendered here by JavaScript -->
    </div>
</div>

@section Scripts {
    <script>
        const fullTreeData = @Html.Raw(Model.JsonContent);
        let treeData = fullTreeData;
        let focusedPersonName = null;
        let isFocusMode = false;
        let isSyncScrollEnabled = false;
        let isSyncing = false; // Flag to prevent recursive scroll events
        const levelContainers = new Map(); // Map level number to container element
        
        // Level color mapping
        const levelColors = {
            0: '#FFE5E5', // Light red
            1: '#E5F3FF', // Light blue
            2: '#E5FFE5', // Light green
            3: '#FFF5E5', // Light orange
            4: '#F0E5FF', // Light purple
            5: '#FFE5F0', // Light pink
            6: '#E5FFFF', // Light cyan
            7: '#FFFFE5'  // Light yellow
        };

        function getLevelColor(level) {
            return levelColors[level] || '#F5F5F5'; // Default gray
        }

        // Create a map for quick person lookup (always use full tree data)
        const personMap = new Map();
        fullTreeData.forEach(person => {
            personMap.set(person.name, person);
        });

        // Filter tree data to show only related people for focus mode
        function filterTreeForFocus(personName) {
            const focusedPerson = personMap.get(personName);
            if (!focusedPerson) return fullTreeData;

            const relatedNames = new Set([personName]);

            // Add parents
            if (focusedPerson.parents) {
                focusedPerson.parents.forEach(parentName => {
                    relatedNames.add(parentName);
                });
            }

            // Add spouses
            if (focusedPerson.spouses) {
                focusedPerson.spouses.forEach(spouseName => {
                    relatedNames.add(spouseName);
                });
            }

            // Add siblings
            if (focusedPerson.siblings) {
                focusedPerson.siblings.forEach(siblingName => {
                    relatedNames.add(siblingName);
                });
            }

            // Add children
            if (focusedPerson.children) {
                focusedPerson.children.forEach(childName => {
                    relatedNames.add(childName);
                });
            }

            // Return filtered data - only people in the related set
            // But we need to preserve relationships, so filter the full tree
            return fullTreeData.filter(person => relatedNames.has(person.name));
        }

        // Get current people by level from treeData
        function getPeopleByLevel() {
            const peopleByLevel = {};
            treeData.forEach(person => {
                if (!peopleByLevel[person.level]) {
                    peopleByLevel[person.level] = [];
                }
            peopleByLevel[person.level].push(person);
            });
            return peopleByLevel;
        }

        // Get all levels sorted
        function getLevels(peopleByLevel) {
            return Object.keys(peopleByLevel).map(Number).sort((a, b) => a - b);
        }

        // Organize people in each level so spouses and siblings are adjacent
        function organizeLevelPeople(people) {
            const processed = new Set();
            const result = [];
            
            // Build a map of siblings at the same level
            const siblingGroups = new Map();
            
            people.forEach(person => {
                if (person.siblings && person.siblings.length > 0) {
                    // Get siblings at the same level
                    const sameLevelSiblings = person.siblings
                        .map(siblingName => personMap.get(siblingName))
                        .filter(sibling => sibling && sibling.level === person.level);
                    
                    if (sameLevelSiblings.length > 0) {
                        // Create a group key from sorted names of all siblings including this person
                        const allSiblings = [person, ...sameLevelSiblings];
                        const siblingNames = allSiblings.map(p => p.name).sort();
                        const groupKey = siblingNames.join('|');
                        
                        // Store the group if not already stored
                        if (!siblingGroups.has(groupKey)) {
                            siblingGroups.set(groupKey, allSiblings);
                        }
                    }
                }
            });
            
            // Process people: first handle those with siblings, then others
            const siblingGroupKeysProcessed = new Set();
            
            people.forEach(person => {
                if (processed.has(person.name)) return;
                
                // Check if this person is part of a sibling group
                let siblingGroup = null;
                let groupKey = null;
                
                for (const [key, group] of siblingGroups.entries()) {
                    if (group.some(p => p.name === person.name) && !siblingGroupKeysProcessed.has(key)) {
                        siblingGroup = group;
                        groupKey = key;
                        break;
                    }
                }
                
                // If part of a sibling group, add all siblings together
                if (siblingGroup) {
                    siblingGroupKeysProcessed.add(groupKey);
                    
                    siblingGroup.forEach(sibling => {
                        if (!processed.has(sibling.name)) {
                            processed.add(sibling.name);
                            result.push(sibling);
                            
                            // Add spouses right after the sibling
                            if (sibling.spouses && sibling.spouses.length > 0) {
                                sibling.spouses.forEach(spouseName => {
                                    const spouse = personMap.get(spouseName);
                                    if (spouse && !processed.has(spouseName) && spouse.level === sibling.level) {
                                        processed.add(spouseName);
                                        result.push(spouse);
                                    }
                                });
                            }
                        }
                    });
                } else {
                    // Person without siblings (or siblings not at same level)
                    processed.add(person.name);
                    result.push(person);
                    
                    // Add spouses right after the person
                    if (person.spouses && person.spouses.length > 0) {
                        person.spouses.forEach(spouseName => {
                            const spouse = personMap.get(spouseName);
                            if (spouse && !processed.has(spouseName) && spouse.level === person.level) {
                                processed.add(spouseName);
                                result.push(spouse);
                            }
                        });
                    }
                }
            });
            
            return result;
        }

        // Enter focus mode
        function enterFocusMode(personName) {
            focusedPersonName = personName;
            isFocusMode = true;
            treeData = filterTreeForFocus(personName);
            
            // Show exit button
            document.getElementById('exitFocusBtn').style.display = 'inline-block';
            
            // Update title
            const focusedPerson = personMap.get(personName);
            document.getElementById('treeTitle').textContent = `Family Tree: @Model.FileName (Focus: ${personName})`;
            
            renderTree();
        }

        // Exit focus mode
        function exitFocusMode() {
            focusedPersonName = null;
            isFocusMode = false;
            treeData = fullTreeData;
            
            // Hide exit button
            document.getElementById('exitFocusBtn').style.display = 'none';
            
            // Restore title
            document.getElementById('treeTitle').textContent = 'Family Tree: @Model.FileName';
            
            renderTree();
        }

        // Render the tree
        function renderTree() {
            const container = document.getElementById('treeContent');
            container.innerHTML = '';
            levelContainers.clear(); // Clear previous references

            const peopleByLevel = getPeopleByLevel();
            const levels = getLevels(peopleByLevel);

            levels.forEach(level => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-container mb-4';
                levelDiv.style.backgroundColor = getLevelColor(level);
                levelDiv.style.padding = '20px';
                levelDiv.style.borderRadius = '8px';
                levelDiv.style.border = '2px solid ' + adjustColorBrightness(getLevelColor(level), -20);

                const levelTitle = document.createElement('h4');
                levelTitle.textContent = `Level ${level}`;
                levelTitle.className = 'mb-3';
                levelTitle.style.color = '#333';
                levelDiv.appendChild(levelTitle);

                // Create horizontally scrollable container
                const peopleContainer = document.createElement('div');
                peopleContainer.className = 'level-people-container';
                peopleContainer.dataset.level = level;
                
                // Store reference to this level container
                levelContainers.set(level, peopleContainer);
                
                // Add scroll event listener for sync
                peopleContainer.addEventListener('scroll', handleLevelScroll);
                
                // Organize people so spouses are adjacent
                const organizedPeople = organizeLevelPeople(peopleByLevel[level]);
                
                organizedPeople.forEach((person, index) => {
                    const personBox = createPersonBox(person);
                    peopleContainer.appendChild(personBox);
                    
                    // Check if next person is a spouse (bidirectional check) and add connection line
                    if (index < organizedPeople.length - 1) {
                        const nextPerson = organizedPeople[index + 1];
                        const isSpouse = (person.spouses && person.spouses.includes(nextPerson.name)) ||
                                        (nextPerson.spouses && nextPerson.spouses.includes(person.name));
                        if (isSpouse) {
                            const connector = createSpouseConnector();
                            peopleContainer.appendChild(connector);
                        } else {
                            // Add space between non-spouse boxes
                            const spacer = document.createElement('div');
                            spacer.style.width = '20px';
                            spacer.style.flexShrink = '0';
                            peopleContainer.appendChild(spacer);
                        }
                    }
                });

                levelDiv.appendChild(peopleContainer);
                container.appendChild(levelDiv);
            });
        }

        function createPersonBox(person) {
            const box = document.createElement('div');
            box.className = 'person-box';
            box.dataset.personName = person.name;
            
            // Check if this is the focused person
            const isFocused = isFocusMode && person.name === focusedPersonName;
            const borderColor = isFocused ? '#dc3545' : '#333';
            const backgroundColor = isFocused ? '#ffcccc' : 'white';
            
            box.style.cssText = `
                padding: 12px 20px;
                background-color: ${backgroundColor};
                border: 3px solid ${borderColor};
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.3s;
                position: relative;
                min-width: 150px;
                flex-shrink: 0;
                text-align: center;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            `;

            box.innerHTML = `<strong>${escapeHtml(person.name)}</strong>`;

            // Add click handler for focus mode
            box.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isFocusMode || person.name !== focusedPersonName) {
                    enterFocusMode(person.name);
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
            });

            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                if (!isFocused) {
                    box.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                } else {
                    box.style.boxShadow = '0 2px 4px rgba(220, 53, 69, 0.3)';
                }
            });

            return box;
        }

        function createSpouseConnector() {
            const connector = document.createElement('div');
            connector.className = 'spouse-connector';
            connector.style.cssText = `
                width: 20px;
                height: 2px;
                background: repeating-linear-gradient(
                    to right,
                    #FF6B6B 0px,
                    #FF6B6B 3px,
                    transparent 3px,
                    transparent 6px
                );
                margin: 0 4px;
                flex-shrink: 0;
                align-self: center;
            `;
            
            return connector;
        }

        function adjustColorBrightness(hex, percent) {
            const num = parseInt(hex.replace("#", ""), 16);
            const r = Math.min(255, Math.max(0, (num >> 16) + percent));
            const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
            const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // Get person at the left edge of a scrollable container
        function getPersonAtLeftEdge(container) {
            const containerRect = container.getBoundingClientRect();
            const leftEdge = containerRect.left;
            const centerY = containerRect.top + containerRect.height / 2;
            
            // Find all person boxes in this container
            const personBoxes = container.querySelectorAll('.person-box');
            let closestBox = null;
            let closestDistance = Infinity;
            
            personBoxes.forEach(box => {
                const boxRect = box.getBoundingClientRect();
                // Check if box is visible and calculate distance from left edge
                if (boxRect.top < centerY && boxRect.bottom > centerY) {
                    const distance = Math.abs(boxRect.left - leftEdge);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBox = box;
                    }
                }
            });
            
            return closestBox ? closestBox.dataset.personName : null;
        }

        // Scroll container to show a specific person at the left edge
        function scrollToPerson(container, personName) {
            const personBox = container.querySelector(`[data-person-name="${personName}"]`);
            if (!personBox) return false;
            
            const containerRect = container.getBoundingClientRect();
            const boxRect = personBox.getBoundingClientRect();
            const scrollLeft = container.scrollLeft;
            const targetScroll = scrollLeft + (boxRect.left - containerRect.left);
            
            container.scrollTo({
                left: targetScroll,
                behavior: 'auto' // Instant scroll to avoid animation during sync
            });
            
            return true;
        }

        // Handle scroll event on a level container
        function handleLevelScroll(event) {
            if (!isSyncScrollEnabled || isSyncing) return;
            
            const scrolledContainer = event.target;
            const scrolledLevel = parseInt(scrolledContainer.dataset.level);
            
            // Get the person at the left edge of the scrolled container
            const personName = getPersonAtLeftEdge(scrolledContainer);
            if (!personName) return;
            
            const person = personMap.get(personName);
            if (!person) return;
            
            // Set syncing flag to prevent recursive events
            isSyncing = true;
            
            // Sync parent levels (higher level numbers = lower in tree, but we want to go up)
            // Actually, level 0 is highest (grandparents), so lower level number = parent
            if (person.parents && person.parents.length > 0) {
                person.parents.forEach(parentName => {
                    const parent = personMap.get(parentName);
                    if (parent && parent.level < scrolledLevel) {
                        const parentContainer = levelContainers.get(parent.level);
                        if (parentContainer && parentContainer !== scrolledContainer) {
                            scrollToPerson(parentContainer, parentName);
                        }
                    }
                });
            }
            
            // Sync child levels (higher level number = children)
            if (person.children && person.children.length > 0) {
                person.children.forEach(childName => {
                    const child = personMap.get(childName);
                    if (child && child.level > scrolledLevel) {
                        const childContainer = levelContainers.get(child.level);
                        if (childContainer && childContainer !== scrolledContainer) {
                            scrollToPerson(childContainer, childName);
                        }
                    }
                });
            }
            
            // Reset syncing flag after a short delay
            setTimeout(() => {
                isSyncing = false;
            }, 50);
        }

        // Toggle sync scroll feature
        function toggleSyncScroll() {
            isSyncScrollEnabled = !isSyncScrollEnabled;
            const statusElement = document.getElementById('syncScrollStatus');
            const iconElement = document.getElementById('syncScrollIcon');
            const button = document.getElementById('syncScrollBtn');
            
            if (isSyncScrollEnabled) {
                statusElement.textContent = 'On';
                iconElement.textContent = 'ðŸ”—';
                button.classList.remove('btn-info');
                button.classList.add('btn-success');
            } else {
                statusElement.textContent = 'Off';
                iconElement.textContent = 'ðŸ”—';
                button.classList.remove('btn-success');
                button.classList.add('btn-info');
            }
        }

        // Make toggleSyncScroll globally available
        window.toggleSyncScroll = toggleSyncScroll;

        // Initialize tree when page loads
        window.addEventListener('load', () => {
            renderTree();
            
            // Setup exit focus button listener
            const exitBtn = document.getElementById('exitFocusBtn');
            if (exitBtn) {
                exitBtn.addEventListener('click', exitFocusMode);
            }
            
            // Setup sync scroll toggle button listener
            const syncBtn = document.getElementById('syncScrollBtn');
            if (syncBtn) {
                syncBtn.addEventListener('click', toggleSyncScroll);
            }
        });

        window.addEventListener('resize', () => {
            renderTree();
        });
    </script>
}

<style>
    .tree-container {
        min-height: 100vh;
        padding: 20px;
        background-color: #f8f9fa;
    }

    .tree-content {
        overflow-y: auto;
        max-height: calc(100vh - 120px);
    }

    .level-container {
        position: relative;
        margin-bottom: 20px;
    }

    .level-people-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        overflow-x: auto;
        overflow-y: visible;
        padding: 10px 0;
        gap: 0;
        min-height: 80px;
    }

    .level-people-container::-webkit-scrollbar {
        height: 8px;
    }

    .level-people-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.1);
        border-radius: 4px;
    }

    .level-people-container::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
    }

    .level-people-container::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.5);
    }

    .person-box {
        user-select: none;
    }

    .spouse-connector {
        display: flex;
        align-items: center;
        justify-content: center;
    }
</style>
